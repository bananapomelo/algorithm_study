评价维度:
    1. 运行效率: 时间复杂度低, 运行次数少
    2. 就地性: 在原数组上进行排序, 节省内存
    3. 稳定性: 相等的时候相对循序不发生改变
    4. 自适应性: 复杂度受到输入数据的影响
    5. 是否基于比较: 以来比较符号(< = >), 理论最优时间复杂度为O(nlogn), 非比较为O(n)

1. 冒泡排序法
    设数组的长度为，冒泡排序的步骤为：
    1.首先，对(n)个元素执行“冒泡”，将数组的最大元素交换至正确位置，
    2.接下来，对剩余(n-1)个元素执行“冒泡”，将第二大元素交换至正确位置。
    3.以此类推，经过(n-1)轮“冒泡”后，前(n-1)大的元素都被交换至正确位置。
    4.仅剩的一个元素必定是最小元素，无需排序，因此数组排序完成。

    算法特性: 
        1. 时间复杂度为O(n^2), 自适应排序, 引入flag标志, 最优时间复杂度为O(n);
        2. 空间复杂度为O(1), 原地排序;
        3. 稳定性

2. 选择排序
    选择排序Selection Sort山的工作原理非常直接：开启一个循环，每轮从未排序区间选择最小的元素，
    将其放到已排序区间的末尾。
    设数组的长度为，选择排序的算法流程如下：
    1.初始状态下，所有元素未排序，即未排序（索引）区间为[0，n - 1]。
    2.选取区间[0, n - 1]中的最小元素，将其与索引0处元素交换。完成后，数组前1个元素已排序。
    3.选取区间[1, n - 1]中的最小元素，将其与索引1处元素交换。完成后，数组前2个元素已排序。
    4.以此类推。经过(n - 1)轮选择与交换后，数组前n一1个元素已排序。
    5.仅剩的一个元素必定是最大元素，无需排序，因此数组排序完成。

    算法特性: 
        1. 时间复杂度为O(n^2), 非自适应排序
        2. 空间复杂度为O(1), 原地排序;
        3. 非稳定性, 相等元素的相对顺序会发生改变
        4. 

3. 插入排序
    插入排序的整体流程如下：
    1.初始状态下，数组的第1个元素已完成排序。
    2.选取数组的第2个元素作为base,将其插入到正确位置后，数组的前2个元素已排序。
    3.选取第3个元素作为base,将其插入到正确位置后，数组的前3个元素已排序。
    4.以此类推，在最后一轮中，选取最后一个元素作为base,将其插入到正确位置后，所有元素均已排序。

    算法特性:
        1. 时间复杂度为O(n^2), 自适应排序
        2. 空间复杂度为O(1), 原地排序
        3. 稳定排序, 相等的元素插入到右侧, 不会改变顺序

    插入排序优势:
        1. 在数据量较小的情况下, 插入排序比快排更适合, 因为快排基于分治, 计算量比插入排序大
        2. 与选择和冒泡排序相比, 插入排序基于赋值, 计算开销小.

4. 快速排序

    快速排序的核心操作是「哨兵划分」，其目标是：选择数组中的某个元素作为“基准数”，将所有小于
    基准数的元素移到其左侧，而大于基准数的元素移到其右侧。具体来说，哨兵划分的流程为：
    1.选取数组最左端元素作为基准数，初始化两个指针ⅰ和j分别指向数组的两端；
    2.设置一个循环，在每轮中使用i(j)分别寻找第一个比基准数大(小)的元素，然后交换这两个
    元素；
    3.循环执行步骤2.，直到i和j相遇时停止，最后将基准数交换至两个子数组的分界线；
    哨兵划分完成后，原数组被划分成三部分：左子数组、基准数、右子数组，且满足"左子数组任意元素
    ≤基准数≤右子数组任意元素"。因此，我们接下来只需对这两个子数组进行排序。

    1.首先，对原数组执行一次「哨兵划分」，得到未排序的左子数组和右子数组；
    2.然后，对左子数组和右子数组分别递归执行「哨兵划分」；
    3.持续递归，直至子数组长度为1时终止，从而完成整个数组的排序；

    算法特性: 
        1. 时间复杂度为O(nlogn), 自适应排序
        2. 空间复杂度为O(n), 原地排序
        3. 非稳定排序

    快排为什么快:
        1. 相较于归并排序和堆排序, 虽然最坏时间复杂度为O(n^2)(完全倒序), 但是出现的概率很低
        2. 缓存使用效率高: 可以将整个数组加载到缓存空间中
        3. 复杂度系数低, 交换, 赋值, 比较的次数少.

    基准值优化:
        选取 left, (left + right) / 2, right三个数, 取中位数, 中位数与基准数进行交换, 保证基准数不是最大也不是最小
        选取中位数:
            if ((array[left] < array[mid]) ^ (array[left] < array[right])) {
                return left;
            } else if ((array[mid] < array[left]) ^ (array[mid] < array[right])) {
                return mid;
            } else {
                return right;
            }

    尾递归优化:
        如果完全倒序, 递归的高度将为n - 1
        所以将左右子树中短的一方进行递归, 长的一方重新进行哨兵划分

5. 堆排序
    设数组的长度为，堆排序的流程如下：
        1.输入数组并建立大顶堆。完成后，最大元素位于堆顶。
        2.将堆顶元素（第一个元素）与堆底元素（最后一个元素）交换。完成交换后，堆的长度减1，已排
        序元素数量加1。
        3.从堆顶元素开始，从顶到底执行堆化操作(Sift Dow)。完成堆化后，堆的性质得到修复。
        4.循环执行第2.和3.步。循环一1轮后，即可完成数组排序。
        实际上，元素出堆操作中也包含第2.和3.步，只是多了一个弹出元素的步骤。

    算法特性:
        时间复杂度为O(nlogn), 非自适应排序
        空间复杂度为O(1), 原地排序
        非稳定排序
    
6. 桶排序
    考虑一个长度为几的数组，元素是范围[0,1)的浮点数。桶排序的流程如下：
    1.初始化k个桶，将n个元素分配到k个桶中。
    2.对每个桶分别执行排序（本文采用编程语言的内置排序函数）。
    3.按照桶的从小到大的顺序，合并结果。

    时间复杂度为O(n+k), 每个桶内平均分配时, 每个桶内有n/k个元素, 每个桶的排序时间为O(n/k log n/k), 那所有桶为
        n log n/k, 当k无限大时, 加上遍历每个桶的时间复杂度, 总共为n+k
    自适应排序
    空间复杂度为O(n + k), 非原地排序



























































