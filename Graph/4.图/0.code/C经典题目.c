/*
1.数组部分和的问题
	假设有一个数组 a[N] N<=20
	能不能从数组中任选M个数组元素(M<=N),使其和为k 
	提示:我们可以 利用二进制来进行任选 0000 ---- 1111包含了所有的可能
*/
//遍历0000~00(N个0) 到 1111~11(N个1)
for(x=0;x<(1<<N);x++)
{
	//数1的个数
	//遍历x的每一位 判断
	int sum;
	sum=0;
	int i,m=0;
	for(i=0;i<N;i++)
	{
		if(x&(1<<i))
		{
			m++;//被选择的元素的个数
			sum+=a[i];
		}
	}
	if(m==M&&sum==K)
	{
		//s
	}
}

/*
2.最长升序子序列的长度 (C预科讲一种解法 数据结构结束的时候讲另一种 这个题目有两种解法)
		子序列 不要求连续 前后关系要和原序列一致  
		如:1 4 -3 9 -9 5 9 0   //1 4 5 9
		   1 5 2 3 4 6 -5 -9 10 11 //1 2 3 4 6 10 11

*/
//算法一:DFS
int max = 1;
void  DFS_ARRY(int a[],int n,int depth)
{
	max = depth>max:depth:max;
	int i;
	for(i=n+1;i<N;i++)
	{
		if(a[i]>a[n])
		{
			DFS_ARRY(a,i,depth+1);
		}
	}
}

for(i=0;i<N;i++)
{
	DFS_ARRY(a,i,1);//算出以a[i]开头的所有的字串的最长的长度
}


//算法二:动态规划
int a[N] = {1 ,5 ,2 ,3 ,4 ,6 ,-5 ,-9 ,10 ,11};
int b[N] = {1};//辅助向量

int i,j;
for(i=1;i<N;i++)
{
	for(j=0;j<i;j++)
	{
		if(a[i]>a[j]&&b[i]<=b[j])
		{
			b[i]=b[j]+1;
		}
	}
}
















