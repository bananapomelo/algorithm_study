一. 时间复杂度分析
    1. 时间复杂度计算的不是算法运行时间, 而是算法运行时间随着数据量变大时的增长趋势
    2. 推算方法:
        (1) 统计操作数量
            [1] 忽略与n无关的操作
            [2] 省略所有系数
            [3] 循环嵌套时使用乘法
        (2) 判断渐进上界
            时间复杂度由最高阶的项决定
                10000                   O(1)
                3n + 2                  O(n)
                2n^2 + 3n + 2           O(n^2)
                n^3 + 10000n^2          O(n^3)
                2^n + 10000n^10000      O(2^n)
    3. 常见复杂度排序
        O(1) < O(log n) < O(n) < O(nlogn) < O(n^2) < O(2^n) < O(n!)
        (1) O(1)
            常数阶的操作数量与输入数据大小n无关.
        (2) O(n)
            常见于单层循环中
            遍历数组和遍历链表
        (3) O(n^2)
            常见于循环嵌套, 外层和内层循环复杂度都为O(n),合并相乘为O(n^2)
        (4) O(2^n)
            常见于递归运算
            int expRecur(int n){
                if (n == 1)
                    return 1;
                return expRecur(n - 1) + expRecur(n - 1) + 1
            }
        (5) O(logn)
            常见于二分查找,分治算法, 递归树
        (6) O(nlogn)
            常见于循环嵌套,两层复杂度分别为O(logn)和O(n)
        (7) O(n!)
        
二. 空间复杂度
    1. 算法相关空间
        输入空间, 暂存空间, 输出空间
        暂存空间又分为: 暂存数据, 栈帧空间, 指令空间
        空间复杂度一般统计: 暂存数据, 输出数据, 栈帧空间
    
        int algorithm(int n){   //输入数据
            const int a = 0;    //暂存数据(常量)
            int b = 0;          //暂存数据(变量)
            int c = func();     //栈帧空间(调用函数)
            return a + b + c    //输出数据
        }
    2. 推算方法 
        通常只关注最差空间复杂度
        最差: 以最差输入数据为准
             以算法运行过程中的峰值内存为准
        递归函数中, 统计栈帧空间
    3. 常见类型
        O(1) < O(log n) < O(n) < O(n^2) < O(2^n)








        

